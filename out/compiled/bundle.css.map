{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Depot.svelte",
    "../../DepotSheet.svelte",
    "../../ImageField.svelte",
    "../../NumberField.svelte",
    "../../TextField.svelte"
  ],
  "sourcesContent": [
    "<!--\nCopyright 2020 Kyle Kukshtel\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script>\n    import Depot from './Depot/Depot.svelte'\n    import { onMount, setContext } from 'svelte';\n    import resolvePath from 'object-resolve-path';\n\n\tonMount(() => {\n        setContext(\"nonce\", nonce);\n        setContext(\"iconPaths\", icons);\n        vscode.postMessage({\n            type: 'init-view',\n\t\t});\n    });\n    \n\n\tlet dataType = \"\";\n    let jsonData = {};\n\n\tfunction windowMessage(event) {\n        const message = event.data; // The json data that the extension sent\n\t\tswitch (message.type) {\n            case 'init':\n\t\t\t\tconsole.log(\"initing view\");\n                //the extension is sending us an init event with the document text\n                //not this is the document NOT the state, the state takes precendece\n                const state = vscode.getState();\n                if (state) {\n                    //we push this state from the vscode workspace to the JSON this component is looking at\n                    console.log(\"found previous state: \" + state.text);\n                    updateContent(state.text);\n                }\n                else\n                {\n                    //grab new content\n                    console.log(\"no previous state: initing\");\n                    // this pings the document to send us its state\n                    // it's then recieved in the windowMessage function where we update our content\n                    updateContent(message.text);\n\t\t\t\t}\n\t\t\t\tdataType = message.jsonType;\n                return;\n\t\t\tcase 'update':\n                console.log(\"updating view\");\n\t\t\t\tconst text = message.text;\n\n                // Update our webview's content\n\t\t\t\tupdateContent(text);\n\n\t\t\t\t// Then persist state information.\n\t\t\t\t// This state is returned in the call to `vscode.getState` below when a webview is reloaded.\n\t\t\t\tvscode.setState({ text });\n\n                return;\n            case 'filePicked':\n                var dataPath = message.fileKey;\n                if(\"linePath\" in dataPath) {\n                    let line = resolvePath(jsonData[\"sheets\"][dataPath.sheet].lines, dataPath.linePath);\n                    line[dataPath.lineIndex][dataPath.column.name] = message.filePath;\n                } else {\n                    jsonData[\"sheets\"][dataPath.sheet].lines[dataPath.lineIndex][dataPath.column.name] = message.filePath;\n                }\n                vscode.postMessage({\n                    type: 'update',\n                    data: jsonData\n                });\n                return;\n\t\t}\n    }\n\t\n\tfunction handleMessage(event) {\n        console.log(event);\n        switch (event.detail.type) {\n            case \"update\":\n                console.log(\"pushing data\",jsonData)\n                //this is where we could conform the data, like flooring an int field if it gets a float value\n                vscode.postMessage({\n                    type: 'update',\n                    data: jsonData\n                });\n                break;\n            case \"pickFile\":\n                console.log(\"firing file picker\");\n                vscode.postMessage({\n                    type: 'pickFile',\n                    fileKey: event.detail.fileKey\n                });\n                break;\n            default:\n                break;\n        }\n        \n\t}\n\n\tfunction updateContent(/** @type {string} */ text) {\n        console.log(\"updating content\");\n\t\ttry {\n            console.log(JSON.parse(text));\n            // interactableData.update(n => n = JSON.parse(text))\n            jsonData = JSON.parse(text);\n            // vscode.window.showInformationMessage(interactableJSON);\n\t\t} catch {\n            // vscode.window.showErrorMessage(\"json read issue\");\n\t\t\t// notesContainer.style.display = 'none';\n\t\t\t// errorContainer.innerText = 'Error: Document is not valid json';\n\t\t\t// errorContainer.style.display = '';\n\t\t\treturn;\n\t\t}\n\t}\n</script>\n\n<svelte:window on:message={windowMessage}/>\n{#if dataType == \"\"}\n\t<p>Loading</p>\n{:else if dataType === \"depot\"}\n    <Depot bind:data={jsonData} on:message={handleMessage}/>\n{:else}\n\t<p>Error: Invalid Data Type {dataType}</p>\n{/if}\n\n<style>\n\tmain {\n\t\ttext-align: left;\n\t\tpadding: 1em;\n\t\tmax-width: 240px;\n\t\tmargin: 0 auto;\n\t}\n\n\th1 {\n\t\tcolor: #ff3e00;\n\t\ttext-transform: uppercase;\n\t\tfont-size: 4em;\n\t\tfont-weight: 100;\n\t}\n\n\t@media (min-width: 640px) {\n\t\tmain {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n\n\t/* Table Stuff */\n\t:global(table) {\n        /* border: 2px solid #252526; */\n        width: 100%;\n        text-align: left;\n        border-collapse: collapse;\n    }\n    :global(table td, table th) {\n        border:3px solid #252526;\n        padding: 0px;\n        /* width: 50% */\n    } \n    :global(table tbody td) {\n        font-size: 13px;\n    }\n    :global(table tr td.fieldLabel) {\n        /* padding-left: 5px; */\n        padding: 5px;\n    }\n    :global(table th) {\n        background: #252526;\n        font-size: 13px;\n        font-weight: bold;\n        text-align: left;\n    }\n\n</style>",
    "<!--\nCopyright 2020 Kyle Kukshtel\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script>\nimport { createEventDispatcher, getContext } from 'svelte';\nimport resolvePath from 'object-resolve-path';\nimport {defaults} from './depotDefaults';\nimport DepotOptions from './DepotOptions.svelte';\nimport DepotSheet from './DepotSheet.svelte';\nimport DepotConfigurator from './DepotConfigurator.svelte';\nimport { v4 as uuidv4 } from 'uuid';\nexport let data;\nlet debug = false;\nlet showLineGUIDs = false;\nlet previewDisclosedFields = false;\nlet showNestedNames = true;\nlet showNestedPaths = false;\nlet allowSchemaEditing = true;\nlet allowAddRemoveItems = true;\nlet iconPaths = getContext(\"iconPaths\");\n\nconst dispatch = createEventDispatcher();\nfunction sheetsUpdated() {\n    // selectedSheetlineData = data.sheets[selectedSheet].lines;\n    // selectedSheetData = data.sheets[selectedSheet];\n    dispatch('message', {\n        \"type\" : \"update\"\n    });\n}\n\nlet selectedSheet = 0;\nfunction focusSheet(index) {\n    selectedSheet = index;\n}\n\nlet listVisibility = {};\n\nfunction getBannedNames(referenceSheetGUID, config) {\n    var sheetNames = [];\n    for(var o in data.sheets) {\n        if(config.operation === \"new\" || \n          (config.operation === \"edit\" && referenceSheetGUID in data.sheets && (data.sheets[o].name !== data.sheets[data.sheets.indexOf(sheet => sheet.guid === referenceSheetGUID)].name)))\n        {\n            //this means its the currently open sheet, we dont add our name to the banned list, only others\n            sheetNames.push(data.sheets[o].name);\n        }\n    }\n    var columnNames = [];\n    if(data.sheets.length > 0)\n    {\n        var sheetIndex = data.sheets.findIndex(sheet => sheet.guid === referenceSheetGUID);\n        if (sheetIndex >= 0 && data.sheets[sheetIndex].columns.length !== 0) {\n            for(var o in data.sheets[sheetIndex].columns) {\n                if(config.operation === \"new\" || \n                  (config.operation === \"edit\" && (data.sheets[sheetIndex].columns[o].name !== config.editType)))\n                {\n                    //this means its the currently open column, we dont add our name to the banned list, only others\n                    columnNames.push(data.sheets[sheetIndex].columns[o].name);\n                }\n            }\n        }\n    }\n    return { \"sheetNames\" : sheetNames, \"columnNames\" : columnNames}\n}\n\nlet depotFileInfo = {};\n$: {\n    var sheetNames = [];\n    var sheetGuids = [];\n    var sheetNamesFiltered = [];\n    var sheetGuidsFiltered = [];\n    var lines = {};\n    var columns = {};\n    data.sheets.forEach(sheet => {\n        sheetNames.push(sheet.name);\n        sheetGuids.push(sheet.guid);\n        if(!sheet.hidden)\n        {\n            sheetNamesFiltered.push(sheet.name);\n            sheetGuidsFiltered.push(sheet.guid);\n        }\n        lines[sheet.guid] = { \"names\": [], \"ids\": [], \"guids\" : []};\n        columns[sheet.guid] = { \"names\": [], \"guids\" : [], \"typeStrs\" : []};\n        sheet.lines.forEach(line => {\n            lines[sheet.guid].names.push(line[sheet.displayColumn])\n            lines[sheet.guid].ids.push(line.id)\n            lines[sheet.guid].guids.push(line.guid)\n        });\n        sheet.columns.forEach(column => {\n            columns[sheet.guid].names.push(column.name)\n            columns[sheet.guid].guids.push(column.guid)\n            columns[sheet.guid].typeStrs.push(column.typeStr)\n        });\n        columns[sheet.guid].names.push(\"id\");\n        columns[sheet.guid].names.push(\"guid\");\n    });\n    depotFileInfo = {   \"sheets\" : {\n                            \"names\":sheetNames,\n                            \"guids\":sheetGuids,\n                        },\n                        \"sheetsFiltered\" : {\n                            \"names\":sheetNamesFiltered,\n                            \"guids\":sheetGuidsFiltered,\n                        },\n                        \"lines\" : lines,\n                        \"columns\" : columns,\n                    };\n}\n\nfunction createLines(sheetGUID, amount) {\n    let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === sheetGUID);\n    for (let index = 1; index <= amount; index++) {\n        var newLine = {};\n        newLine[\"guid\"] = uuidv4();\n        newLine[\"id\"] = data.sheets[sheetIndex].lines.length + \"\";\n        data.sheets[sheetIndex].columns.forEach(column => {\n            if(column.typeStr == \"multiple\")\n            {\n                newLine[column.name] = column.defaultValue.split(', ');\n            }\n            else\n            {\n                newLine[column.name] = column.defaultValue;\n            }\n        });\n        data.sheets[sheetIndex].lines.push(newLine);\n    }\n    sheetsUpdated();\n}\n\nfunction getSubsheetParentInfo(subsheetIndex) {\n    var colGUID = data.sheets[subsheetIndex].columnGUID;\n    let parent = {};\n    let parentSheetIndex = data.sheets.findIndex(sheet => sheet.guid === data.sheets[subsheetIndex].parentSheetGUID);\n    parent[\"parentIndex\"] = parentSheetIndex;\n    let refColumnIndex = data.sheets[parentSheetIndex].columns.findIndex(sheet => sheet.guid === colGUID);\n    let refColumn = data.sheets[parentSheetIndex].columns[refColumnIndex];\n    let columnNamePath = [refColumn.name];\n    if(data.sheets[parentSheetIndex].hidden)\n    {\n        parent = getSubsheetParentInfo(parentSheetIndex);\n        columnNamePath = columnNamePath.concat(parent.path);\n    }\n    parent[\"path\"] = columnNamePath;\n    return parent;\n}\n\nfunction getValidLinesWithListPath(lines,pathTrail,trailIndex,basePath) {\n    let paths = [];\n    //lists and top level sheets\n    if(Array.isArray(lines)) {\n        lines.forEach((line,lineIndex) => {\n            //if line[columnName].length > 0 - aka if there are nested lines here\n            if(Array.isArray(line[pathTrail[trailIndex]])) {\n                if(line[pathTrail[trailIndex]].length > 0) {\n                    // [0].listVarName\n                    var validPath = basePath + `[${lineIndex}][\"${pathTrail[trailIndex]}\"]`;\n                    if(trailIndex + 1 < pathTrail.length) {\n                        paths = paths.concat(getValidLinesWithListPath(line[pathTrail[trailIndex]],pathTrail,trailIndex+1,validPath).paths)\n                    } else {\n                        paths.push(validPath);\n                    }\n                }\n            } else {\n                //props\n                if(Object.keys(line[pathTrail[trailIndex]]).length > 0) {\n                    var validPath = basePath + `[${lineIndex}][\"${pathTrail[trailIndex]}\"]`;\n                    if(trailIndex + 1 < pathTrail.length) {\n                        paths = paths.concat(getValidLinesWithListPath(line[pathTrail[trailIndex]],pathTrail,trailIndex+1,validPath).paths)\n                    } else {\n                        paths.push(validPath);\n                    }\n                }\n            }\n        });\n    } else {\n        console.log(lines);\n        console.log(trailIndex);\n        console.log(pathTrail[trailIndex]);\n        console.log(lines[pathTrail[trailIndex]]);\n        if(Array.isArray(lines[pathTrail[trailIndex]])) {\n            if(lines[pathTrail[trailIndex]].length > 0) {\n                // [0].listVarName\n                var validPath = basePath + `[\"${pathTrail[trailIndex]}\"]`;\n                if(trailIndex + 1 < pathTrail.length) {\n                    paths = paths.concat(getValidLinesWithListPath(lines[pathTrail[trailIndex]],pathTrail,trailIndex+1,validPath).paths)\n                } else {\n                    paths.push(validPath);\n                }\n            }\n        } else {\n            //props\n            if(Object.keys(lines[pathTrail[trailIndex]]).length > 0) {\n                var validPath = basePath + `[\"${pathTrail[trailIndex]}\"]`;\n                if(trailIndex + 1 < pathTrail.length) {\n                    paths = paths.concat(getValidLinesWithListPath(lines[pathTrail[trailIndex]],pathTrail,trailIndex+1,validPath).paths)\n                } else {\n                    paths.push(validPath);\n                }\n            }\n        }\n    }\n    return {\"paths\":paths};\n}\n\nfunction iterateNestedLines(subsheetIndex,iteratorFunction) {\n    //find the topmost sheet - this is because nested sheet info is stored inside the top level line values\n    let parentInfo = getSubsheetParentInfo(subsheetIndex)\n    //reverse the path because it comes it from the perspective of the affected entry, not the sheet itself\n    parentInfo.path.reverse();\n    //grab the paths to the affected lines\n    let affectedLines = getValidLinesWithListPath(data.sheets[parentInfo.parentIndex].lines,parentInfo.path,0,\"\");\n    /*\n        affectedLines is an array of paths from the parent sheet lines down to the affected values\n        [0].level1[0].level2\n        [6].level1[0].level2\n        etc.\n    */\n    console.log(\"paths: \" + affectedLines.paths);\n    affectedLines.paths.forEach(linePath => {\n        /* linePath comes in like [0].level1[0].level2 */\n        // subsheetLines is the array of lines nested inside this line entry\n        console.log(resolvePath(data.sheets[parentInfo.parentIndex].lines, linePath));\n        let subsheetLines = resolvePath(data.sheets[parentInfo.parentIndex].lines, linePath);\n        if(Array.isArray(subsheetLines)) {\n            //top level and subsheet\n            subsheetLines.forEach(line => {\n                console.log(\"destination line:\");\n                console.log(line);\n                iteratorFunction(line);\n            });\n        } else {\n            //props\n            iteratorFunction(subsheetLines);\n        }\n    });\n}\n\nfunction iterateSheetLines(sheetIndex, iteratorFunction) {\n    if(!data.sheets[sheetIndex].hidden) {\n        data.sheets[sheetIndex].lines.forEach(line => {\n            iteratorFunction(line);\n        });\n    } else {\n        iterateNestedLines(sheetIndex,(line) => {\n            iteratorFunction(line);\n        });\n    }\n}\n\nfunction handleConfigUpdate(event) {\n    switch (event.detail.type) {\n        case \"create\":\n            switch (editorConfig.editType) {\n                case \"sheet\":\n                    data.sheets.push(editorData);\n                    focusSheet(data.sheets.length - 1);\n                    editorConfig = {\"active\":false};\n                    createLines(editorData.guid,1); //calls sheets updated as well\n                    break;\n                default: //column\n                    let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === editorConfig.sheetGUID);\n                    data.sheets[sheetIndex].columns.push(editorData);\n                    //if you're creating a column, create a new entry for a column value in every line based off the default value\n                    iterateSheetLines(sheetIndex,(line) => {\n                        if(editorData.typeStr === \"multiple\")\n                        {\n                            line[editorData.name] = editorData.defaultValue.split(', ');\n                        }\n                        else\n                        {\n                            line[editorData.name] = editorData.defaultValue;\n                        }\n                    });\n                    if(editorData.typeStr === \"list\" || editorData.typeStr === \"props\") {\n                        //list and props are used as hidden sheets internally\n                        // make a new sheet that this will reference\n                        let hiddenSheet = JSON.parse(JSON.stringify(defaults[\"sheet\"]));\n                        hiddenSheet[\"hidden\"] = true;\n                        hiddenSheet[\"description\"] = editorData.typeStr+\"@\"+data.sheets[sheetIndex].guid;\n                        if(editorData.typeStr === \"props\") {hiddenSheet[\"isProps\"] = true;}\n                        hiddenSheet[\"parentSheetGUID\"] = data.sheets[sheetIndex].guid;\n                        hiddenSheet[\"columnGUID\"] = editorData.guid;\n                        let guid = uuidv4();\n                        hiddenSheet[\"guid\"] = guid;\n                        //assign the column's sheet param to this new list\n                        data.sheets[sheetIndex].columns[data.sheets[sheetIndex].columns.findIndex(col => col.guid === editorData.guid)].sheet = guid;\n                        hiddenSheet[\"name\"] = editorData.name;\n                        //the list sheet is not configurable\n                        delete hiddenSheet.configurable;\n                        data.sheets.push(hiddenSheet);\n                    }\n                    editorConfig = {\"active\":false};\n                    sheetsUpdated();\n                    break;\n            }\n            break;\n        case \"save\":\n            switch (editorConfig.editType) {\n                case \"sheet\":\n                    data.sheets[selectedSheet] = editorData;\n                    break;\n                default: //column\n                    let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === editorConfig.sheetGUID);\n                    var index = data.sheets[sheetIndex].columns.findIndex(x => x.name === editorConfig.editType); //old name\n                    var oldColumnData = JSON.parse(JSON.stringify(data.sheets[sheetIndex].columns[index]));\n                    data.sheets[sheetIndex].columns[index] = editorData; //column now has new name maybe\n                    //update line entries depending on circumstances - maybe a faster way?\n                    if(editorConfig.editType !== editorData.name) //the name changed\n                    {\n                        iterateSheetLines(sheetIndex,(line) => {\n                            //make a new key and assign it the the old value\n                            line[editorData.name] = line[editorConfig.editType];\n                            //delete the old key\n                            delete line[editorConfig.editType];\n                        });\n\n                        //update display column if it used the old name\n                        if(data.sheets[sheetIndex].displayColumn == editorConfig.editType) {\n                            data.sheets[sheetIndex].displayColumn = editorData.name;\n                        }\n\n                        //TODO: may need to do more here if column name change was referenced by other sheet?\n                    }\n                    if(editorData.typeStr == \"multiple\")\n                    {\n                        iterateSheetLines(sheetIndex,(line) => {\n                            //make sure the multiple only has values possible based on config\n                            //this removes old values if config changes\n                            line[editorData.name] = line[editorData.name].filter(value => editorData.options.includes(value));\n                        });\n                    }\n                    if(editorData.typeStr == \"enum\")\n                    {\n                        iterateSheetLines(sheetIndex,(line) => {\n                            //make sure the enum only has values possible based on config\n                            if(!editorData.options.includes(line[editorData.name]))\n                            {\n                                line[editorData.name] = editorData.defaultValue\n                            }\n                        });\n                    }\n                    if(editorData.typeStr == \"grid\")\n                    {\n                        var visibilityUpdated = false;\n                        if(editorData.defaultValue.length < oldColumnData.defaultValue.length) {\n                            //the list got shorter, need to chop off old values from lines\n                            iterateSheetLines(sheetIndex, (line) => {\n                                line[editorData.name] = line[editorData.name].slice(0,editorData.defaultValue.length);\n                                if(listVisibility.hasOwnProperty(line.guid) && listVisibility[line.guid].guid == editorData.guid)\n                                {\n                                    delete listVisibility[line.guid];\n                                    listVisibility[line.guid] = editorData;\n                                    visibilityUpdated = true;\n                                }\n                            });\n                        }\n                        if(editorData.defaultValue.length > oldColumnData.defaultValue.length) {\n                            //the list got longer, need to add in new values and their default values\n                            var addedDefaultValues = editorData.defaultValue.slice(oldColumnData.defaultValue.length);\n                            iterateSheetLines(sheetIndex, (line) => {\n                                line[editorData.name] = line[editorData.name].concat(addedDefaultValues);\n                                if(listVisibility.hasOwnProperty(line.guid) && listVisibility[line.guid].guid == editorData.guid)\n                                {\n                                    delete listVisibility[line.guid];\n                                    listVisibility[line.guid] = editorData;\n                                    visibilityUpdated = true;\n                                }\n                            });\n                        }\n                        oldColumnData.schema.forEach((dataType, dataIndex) => {\n                            if(dataIndex < editorData.schema.length) { //\n                                if(dataType !== editorData.schema[dataIndex]) {\n                                    //the data type has changed. in this case, we update all lines to use the new default value of the field\n                                    iterateSheetLines(sheetIndex,(line) => {\n                                        line[editorData.name][dataIndex] = editorData.defaultValue[dataIndex];\n                                        if(listVisibility.hasOwnProperty(line.guid) && listVisibility[line.guid].guid == editorData.guid)\n                                        {\n                                            delete listVisibility[line.guid];\n                                            listVisibility[line.guid] = editorData;\n                                            visibilityUpdated = true;\n                                        }\n                                    });\n                                }\n                            }\n                        });\n\n                        if(!visibilityUpdated && \n                           ((oldColumnData.displayWidth !== editorData.displayWidth) || \n                            (oldColumnData.columnWidth !== editorData.columnWidth) || \n                            (oldColumnData.columnHeight !== editorData.columnHeight))) {\n                                //if we havent yet updated the visibility, but something that affects visibility was updated\n                                iterateSheetLines(sheetIndex,(line) => {\n                                    if(listVisibility.hasOwnProperty(line.guid) && listVisibility[line.guid].guid == editorData.guid)\n                                    {\n                                        delete listVisibility[line.guid];\n                                        listVisibility[line.guid] = editorData;\n                                    }\n                                });\n                            }\n                    }\n                    if(editorData.typeStr == \"list\")\n                    {\n                        // let refIndex = data.sheets.findIndex(s => s.guid === editorData.sheet);\n                        // data.sheets[refIndex].name = editorData.name;\n                        //also update the name in list visibility\n                        Object.keys(listVisibility).forEach(key => {\n                            // update column name references if we changed a column name here\n                            if(listVisibility[key].guid === editorData.guid)\n                            {\n                                listVisibility[key].name = editorData.name;\n                            }\n                        });\n                    }\n                    \n                    break;\n            }\n            editorConfig = {\"active\":false};\n            sheetsUpdated();\n            break;\n        case \"delete\":\n            switch (editorConfig.editType) {\n                case \"sheet\":\n                    const deletedGUID = data.sheets[selectedSheet].guid;\n                    //recursively delete any list fields on this sheet\n                    data.sheets[selectedSheet].columns.forEach(column => {\n                        if(column.typeStr === \"list\") {\n                            deleteListColumn(column);\n                        }\n                    });\n                    data.sheets.splice(selectedSheet,1);\n                    focusSheet(0);\n                    //delete any references to this and set to \"\"\n                    data.sheets.forEach(sheet => {\n                        var sheetRefColumns = sheet.columns.filter(column => column.typeStr === \"sheetReference\");\n                        var lineRefColumns = sheet.columns.filter(column => column.typeStr === \"lineReference\");\n                        if(sheetRefColumns.length > 0) {\n                            sheet.lines.forEach(line => {\n                                sheetRefColumns.forEach(column => {\n                                    if(line[column.name] === deletedGUID)\n                                    {\n                                        line[column.name] = \"\";\n                                    }\n                                });\n                            });\n                            sheetRefColumns.forEach(column => {\n                                if(column.defaultValue === deletedGUID)\n                                {\n                                    column.defaultValue = \"\";\n                                }\n                            });\n                        }\n                        if(lineRefColumns.length > 0) {\n                            let editedColumns = [];\n                            lineRefColumns.forEach(column => {\n                                if(column.sheet === deletedGUID)\n                                {\n                                    column.sheet = \"\";\n                                    column.defaultValue = \"\";\n                                    editedColumns.push(column);\n                                }\n                            });\n                            sheet.lines.forEach(line => {\n                                editedColumns.forEach(column => {\n                                    //clear out previous linked values, as they pointed to a now deleted sheet\n                                    line[column.name] = \"\";\n                                });\n                            });\n                        }\n                    });\n                    break;\n                default: //column\n                    let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === editorConfig.sheetGUID);\n                    var index = data.sheets[sheetIndex].columns.findIndex(x => x.name === editorConfig.editType); //old name\n\n                    iterateSheetLines(sheetIndex,(line) => {\n                        if(listVisibility.hasOwnProperty(line.guid) && listVisibility[line.guid].guid == editorData.guid)\n                        {\n                            delete listVisibility[line.guid];\n                        }\n                        delete line[editorConfig.editType];\n                    });\n                   \n                    if(data.sheets[sheetIndex].displayColumn === data.sheets[sheetIndex].columns[index].name)\n                    {\n                        //we deleted the display column, update to default\n                        data.sheets[sheetIndex].displayColumn = defaults[\"sheet\"].displayColumn;\n                    }\n                    if(data.sheets[sheetIndex].columns[index].typeStr === \"list\")\n                    {\n                        deleteListColumn(data.sheets[sheetIndex].columns[index]);\n                    }\n                    //delete the column\n                    data.sheets[sheetIndex].columns.splice(index,1);\n                    //TODO: may need to do more here if column name change was referenced by other sheet?\n                    break;\n            }\n            editorConfig = {\"active\":false};\n            sheetsUpdated();\n            break;\n        case \"close\":\n            editorConfig = {\"active\":false};\n            break;\n        case \"upgradeColumnData\":\n            //this updates a column with a new config\n            let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === editorConfig.sheetGUID);\n            var index = data.sheets[sheetIndex].columns.findIndex(x => x.name === editorConfig.originalData.name); //old name, dont use a new name we may have input into editordata\n            //find discrepancies\n            let targetColumn = data.sheets[sheetIndex].columns[index];\n            Object.keys(defaults[editorData.typeStr]).forEach(key => {\n                if(key !== \"configurable\") {\n                    if (!(key in targetColumn)){\n                        targetColumn[key] = defaults[editorData.typeStr][key];\n                    }\n                } else {\n                    Object.keys(defaults[editorData.typeStr][\"configurable\"]).forEach(configKey => {\n                        if (!(configKey in targetColumn[\"configurable\"])){\n                        targetColumn[\"configurable\"][configKey] = defaults[editorData.typeStr][\"configurable\"][configKey];\n                    }\n                    });\n                }\n            });\n            sheetsUpdated();\n            handleTableAction({\"detail\":{\n                \"type\" : \"editorUpdate\",\n                \"data\" : {\n                    \"active\" : true,\n                    \"operation\" : \"edit\",\n                    \"editType\" : editorConfig.originalData.name,\n                    \"sheetGUID\" : editorConfig.sheetGUID\n                }\n            }});\n            break;\n        default:\n            editorConfig = {\"active\":false};\n            break;\n    }\n}\n\nfunction deleteListColumn(col) {\n    let delSheetIndex = data.sheets.findIndex(sheet => sheet.guid === col.sheet);\n    Object.keys(listVisibility).forEach(key => {\n        if(listVisibility[key].guid === col.guid)\n        {\n            //if the column is deleted, we can remove this entry from visibility\n            delete listVisibility[key];\n        }\n    });\n    data.sheets[delSheetIndex].columns.forEach(column => {\n        if(column.typeStr === \"list\") {\n            deleteListColumn(column);\n        }\n    });\n    data.sheets.splice(delSheetIndex,1);\n}\n\nlet editorConfig = {\"active\" : false}\nlet editorData = {}\nfunction handleTableAction(event) {\n    let sheetIndex = data.sheets.findIndex(sheet => sheet.guid === event.detail.data.sheetGUID);\n    switch (event.detail.type) {\n        case \"editorUpdate\":\n            editorConfig = event.detail.data;\n            editorConfig[\"bannedNames\"] = getBannedNames(editorConfig.sheetGUID,editorConfig);\n            editorConfig[\"depotInfo\"] = depotFileInfo;\n            switch (editorConfig.operation) {\n                case \"new\":\n                    editorData = JSON.parse(JSON.stringify(defaults[editorConfig.editType]));\n                    editorData[\"guid\"] = uuidv4(); //assign columns and sheets guids\n                    if(editorConfig.editType === \"lineReference\")\n                    {\n                        //not sure why enum value not setting to default in the configurator, so set a default here\n                        let defSheet = data.sheets.find(s => s.hidden !== true).guid; //get first unhidden sheet\n                        editorData[\"sheet\"] = defSheet;\n                    }\n                    break;\n                case \"edit\":\n                    switch (editorConfig.editType) {\n                        case \"sheet\":\n                            editorConfig[\"originalData\"] = JSON.parse(JSON.stringify(data.sheets[sheetIndex]));\n                            editorData = JSON.parse(JSON.stringify(data.sheets[sheetIndex]));\n                            break;\n                        default: //column\n                            editorConfig[\"originalData\"] = JSON.parse(JSON.stringify(data.sheets[sheetIndex].columns.find(x => x.name === editorConfig.editType)));\n                            editorData = JSON.parse(JSON.stringify(data.sheets[sheetIndex].columns.find(x => x.name === editorConfig.editType)));\n                            break;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            break;\n        case \"update\":\n            sheetsUpdated();\n            break;\n        case \"lineEdit\":\n            switch (event.detail.data.operation) {\n                case \"remove\":\n                    const deletedGUID = event.detail.data.line.guid;\n                    data.sheets[sheetIndex].lines.splice(event.detail.data.lineIndex,1);\n                    data.sheets.forEach(sheet => {\n                        var lineRefColumns = sheet.columns.filter(column => column.typeStr === \"lineReference\");\n                        if(lineRefColumns.length > 0) {\n                            sheet.lines.forEach(line => {\n                                lineRefColumns.forEach(column => {\n                                    if(line[column.name] === deletedGUID)\n                                    {\n                                        line[column.name] = \"\";\n                                    }\n                                });\n                            });\n                            lineRefColumns.forEach(column => {\n                                if(column.defaultValue === deletedGUID)\n                                {\n                                    column.defaultValue = \"\";\n                                }\n                            });\n                        }\n                    });\n                    if(deletedGUID in listVisibility)\n                    {\n                        delete listVisibility[deletedGUID];\n                    }\n                    break;\n                case \"add\":\n                    if(!data.sheets[sheetIndex].hidden) {\n                        createLines(event.detail.data.sheetGUID,event.detail.data.amount);\n                    }\n                    else {\n                        //line additions to subsheets are handled in DepotSheet\n                    }\n                break;\n                default:\n                    break;\n            }\n            sheetsUpdated();\n            break;\n        case \"pickFile\":\n            //forward events from fields\n            //fileKey={{\"line\":line,\"lineIndex\":i,\"column\":column,\"columnIndex\":c}\n            var fileKey = event.detail.fileKey;\n            fileKey[\"sheet\"] = sheetIndex;\n            if(data.sheets[sheetIndex].hidden) {\n                //find the topmost sheet - this is because nested sheet info is stored inside the top level line values\n                let parentInfo = getSubsheetParentInfo(sheetIndex)\n                //reverse the path because it comes it from the perspective of the affected entry, not the sheet itself\n                parentInfo.path.reverse();\n                //grab the paths to the affected lines\n                let affectedLines = getValidLinesWithListPath(data.sheets[parentInfo.parentIndex].lines,parentInfo.path,0,\"\").paths;\n                //this is every line with this path, we now need to filter this down to the specific \n                let filtered = affectedLines.filter(linePath => {\n                    let subsheetLines = resolvePath(data.sheets[parentInfo.parentIndex].lines, linePath);\n                    return subsheetLines[fileKey.lineIndex].guid == fileKey.line.guid;\n                });\n                //filtered now has one element in it with only the path to the cooresponding line\n                fileKey[\"linePath\"] = filtered[0];\n                fileKey[\"sheet\"] = parentInfo.parentIndex; //the passed in sheet needs to be the parent index\n            }\n            dispatch('message', {\n                \"type\" : \"pickFile\",\n                \"fileKey\" : event.detail.fileKey\n            });\n            break;\n        default:\n            break;\n    }\n}\nfunction createSheet() {\n    editorConfig = {\n        \"active\" : true,\n        \"operation\" : \"new\",\n        \"editType\" : \"sheet\",\n    }\n    editorData = JSON.parse(JSON.stringify(defaults[editorConfig.editType]));\n    let sheetGUID = uuidv4();\n    editorData[\"guid\"] = sheetGUID; //assign columns and sheets guids\n    editorConfig[\"bannedNames\"] = getBannedNames(sheetGUID,editorConfig);\n    editorConfig[\"depotInfo\"] = depotFileInfo;\n}\n\nfunction selectedSheetColumnCreate(columnType) {\n    handleTableAction({\"detail\":{\n        \"type\" : \"editorUpdate\",\n        \"data\" :{\n                \"active\" : true,\n                \"operation\" : \"new\",\n                \"editType\" : columnType,\n                \"sheetGUID\" : data.sheets[selectedSheet].guid\n                }\n    }});\n}\n\nfunction selectedSheetEdit() {\n    handleTableAction({\"detail\":{\n        \"type\" : \"editorUpdate\",\n        \"data\" :{\n                \"active\" : true,\n                \"operation\" : \"edit\",\n                \"editType\" : \"sheet\",\n                \"sheetGUID\" : data.sheets[selectedSheet].guid\n                }\n    }});\n}\n\n</script>\n{#if !data.hasOwnProperty(\"sheets\")}\n    <h1>Depot</h1>\n    <p>Invalid Depot File</p>\n    <p>Use Ctrl/Cmd+Shift+P and select \"Create new Depot File\" to get started</p>\n{:else}\n    {#if data.sheets.length === 0}\n        <h1>Depot</h1>\n        <p>Click the button below to create sheet in Depot and get started</p>\n       <DepotConfigurator debug={debug} data={editorConfig.active ? editorData : {}} config={editorConfig} on:message={handleConfigUpdate}/>\n       {#if !editorConfig.active}\n       <button class=\"buttonIcon padded\" title=\"New sheet\" on:click={createSheet}>\n            <img src={iconPaths[\"newSheet\"].path} alt=\"New Sheet\">\n        </button>\n        {/if}\n    {:else}\n        <h1>{data.sheets[selectedSheet].name}</h1>\n        <p>{data.sheets[selectedSheet].description}</p>\n        <DepotOptions bind:debug={debug}\n                      bind:showLineGUIDs={showLineGUIDs}\n                      bind:previewDisclosedFields={previewDisclosedFields}\n                      bind:showNestedNames={showNestedNames}\n                      bind:showNestedPaths={showNestedPaths} \n                      bind:allowAddRemoveItems={allowAddRemoveItems} \n                      bind:allowSchemaEditing={allowSchemaEditing}/> \n        {#if allowSchemaEditing}\n            <button class=\"buttonIcon padded\" title=\"New sheet\" disabled={editorConfig.active} on:click={createSheet}>\n                <img src={iconPaths[\"newSheet\"].path} alt=\"New Sheet\">\n            </button>\n            <button class=\"buttonIcon padded\" title=\"Edit sheet\" disabled={editorConfig.active} on:click={selectedSheetEdit}>\n                <img src={iconPaths[\"editSheet\"].path} alt=\"Edit Sheet\">\n            </button>\n            {#each Object.keys(defaults) as columnType}\n                {#if columnType !== \"sheet\"}\n                    <button class=\"buttonIcon padded\" disabled={editorConfig.active} title=\"Create new {columnType} column\" on:click={() => selectedSheetColumnCreate(columnType)}>\n                        <img src={iconPaths[defaults[columnType].iconName].path} alt=\"Create new {columnType} column\">\n                    </button>\n                {/if}\n            {/each}\n        {/if}\n        <div>\n        {#each data.sheets as sheet}\n            {#if !sheet.hidden}\n            <button class=\"sheetButton {data.sheets.indexOf(sheet) == selectedSheet ? \"selected\" : \"\"}\" title=\"Select sheet\" on:click={focusSheet(data.sheets.indexOf(sheet))} disabled={editorConfig.active}>{sheet.name}</button>\n            {/if}\n        {/each}\n        </div>\n        <DepotConfigurator debug={debug} data={editorConfig.active ? editorData : {}} config={editorConfig} on:message={handleConfigUpdate}/>\n        {#if !editorConfig.active}\n            <!-- hide the table if editing a field to prevent sending the sheetupdate -->\n            <DepotSheet debug={debug} \n                        showLineGUIDs={showLineGUIDs} \n                        previewDisclosedFields={previewDisclosedFields}\n                        showNestedNames={showNestedNames}\n                        showNestedPaths={showNestedPaths}\n                        allowSchemaEditing={allowSchemaEditing}\n                        allowAddRemoveItems={allowAddRemoveItems}\n                        bind:fullData={data} \n                        bind:sheetData={data.sheets[selectedSheet]} \n                        bind:inputLineData={data.sheets[selectedSheet].lines} \n                        depotInfo={depotFileInfo} \n                        on:message={handleTableAction}\n                        bind:listVisibility={listVisibility}\n                        baseDataPath={data.sheets[selectedSheet].name}/>\n        {/if}\n    {/if}\n{/if}\n\n{#if debug}\n<p>Selected Sheet: {selectedSheet}</p>\n<p>Raw Data:</p>\n<pre>{JSON.stringify({data},null,2)}</pre>\n{/if}\n\n<style>\n    .buttonIcon {\n        background-color: #3A3A3A;\n        border: none;\n        color: white;\n        display: inline-block;\n        cursor: pointer;\n    }\n\n    .buttonIcon:hover {\n        background-color: #2A2D2E;\n    }\n\n    .buttonIcon:focus {\n        outline: none;\n        box-shadow: none;\n    }\n    .buttonIcon:active:focus {\n        outline: none;\n        box-shadow: none;\n    }\n    .buttonIcon.padded {\n        margin: 5px 5px 5px 0px;\n        width: 45px;\n        height: 45px;\n    }\n\n    .sheetButton {\n        background-color: #3A3A3A;\n        border: none;\n        color: white;\n        display: inline-block;\n        cursor: pointer;\n        margin: 0px 5px 0px 0px;\n        padding: 8px 8px 8px 8px;\n    }\n    .sheetButton:hover {\n        background-color: #252526;\n    }\n    .sheetButton.selected {\n        background-color: #252526;\n    }\n    .sheetButton:focus {\n        outline: none;\n        box-shadow: none;\n    }\n    .sheetButton:active:focus {\n        outline: none;\n        box-shadow: none;\n    }\n</style>",
    "<!--\nCopyright 2020 Kyle Kukshtel\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n-->\n\n<script>\nimport { getContext } from 'svelte';\nimport TextField from \"../Fields/TextField.svelte\";\nimport BooleanField from '../Fields/BooleanField.svelte';\nimport EnumField from '../Fields/EnumField.svelte';\nimport ImageField from '../Fields/ImageField.svelte';\nimport LongTextField from '../Fields/LongTextField.svelte';\nimport MultipleField from '../Fields/MultipleField.svelte';\nimport NumberField from '../Fields/NumberField.svelte';\nimport FileField from '../Fields/FileField.svelte';\nimport {defaults} from './depotDefaults';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { createEventDispatcher } from 'svelte';\nimport GridFieldTableEditor from '../Fields/GridFieldTableEditor.svelte';\nexport let fullData;\nexport let sheetData;\nexport let inputLineData;\n//maybe just switch on sheetData below instead of trying to cast an array?\n//that way you could also (i think) just write to the single bound lineData?\n$: {\n    if(Array.isArray(inputLineData)) {\n        lineData = inputLineData;\n    } else {\n        //this is a props sheet so we need to spoof a linedata array\n        lineData = [inputLineData]\n    }\n}\nlet lineData;\n//from DepotOptions.svelte\nexport let debug;\nexport let showLineGUIDs;\nexport let previewDisclosedFields;\nexport let showNestedNames;\nexport let showNestedPaths;\nexport let allowSchemaEditing;\nexport let allowAddRemoveItems;\n\n\n\nexport let depotInfo;\nexport let originLineGUID = \"\";\nexport let listVisibility = {};\nconst dispatch = createEventDispatcher();\nlet iconPaths = getContext(\"iconPaths\");\n\nexport let lastHovered;\nexport let parentGUID = \"\";\nexport let baseDataPath = \"\";\n\nfunction enterSheet() {\n    dispatch('message', {\n        \"type\" : \"hoverUpdate\",\n        \"data\" : {\n            \"action\" : \"enter\",\n            \"sheetGUID\" : sheetData.guid,\n            \"parentGUID\" : parentGUID,\n        }\n    });\n}\n\nfunction leaveSheet() {\n    if(lastHovered == sheetData.guid) {\n        lastHovered = \"\";\n    }\n    dispatch('message', {\n        \"type\" : \"hoverUpdate\",\n        \"data\" : {\n            \"action\" : \"exit\",\n            \"sheetGUID\" : sheetData.guid,\n            \"parentGUID\" : parentGUID\n        }\n    });\n}\n\nfunction editColumn(column) {\n    dispatch('message', {\n        \"type\" : \"editorUpdate\",\n        \"data\" : {\n            \"active\" : true,\n            \"operation\" : \"edit\",\n            \"editType\" : column,\n            \"sheetGUID\" : sheetData.guid\n        }\n    });\n}\n\nfunction removeLine(lineIndex, line, originGUID) {\n    dispatch('message', {\n        \"type\" : \"lineEdit\",\n        \"data\" : {\n            \"operation\" : \"remove\",\n            \"lineIndex\" : lineIndex,\n            \"line\" : line,\n            \"originLineGUID\" : originGUID,\n            \"sheetGUID\" : sheetData.guid\n        }\n    });\n}\n\nfunction addLines(amount,originGUID) {\n    dispatch('message', {\n        \"type\" : \"lineEdit\",\n        \"data\" : {\n            \"operation\" : \"add\",\n            \"amount\" : amount,\n            \"originLineGUID\" : originGUID,\n            \"sheetGUID\" : sheetData.guid\n        }\n    });\n}\n\nfunction createColumn(columnType) {\n    dispatch('message', {\n        \"type\" : \"editorUpdate\",\n        \"data\" :{\n                \"active\" : true,\n                \"operation\" : \"new\",\n                \"editType\" : columnType,\n                \"sheetGUID\" : sheetData.guid\n                }\n    });\n}\n\nfunction handleSubTableEvent(event) {\n    console.log(\"handing subtable event\");\n    console.log(event);\n    console.log(originLineGUID)\n    switch (event.detail.type) {\n        case \"lineEdit\":\n            let nestedSheetGUID = event.detail.data.sheetGUID;\n            let nestedSheetIndex = fullData.sheets.findIndex(sheet => sheet.guid === nestedSheetGUID);\n            //this is the line in the parent sheet that caught the event from the subsheet\n            var refLineIndex = lineData.findIndex(line => line.guid === event.detail.data.originLineGUID);\n            var refLineColumn = listVisibility[event.detail.data.originLineGUID];\n            switch (event.detail.data.operation) {\n                case \"add\":\n                    console.log(\"adding nested line from\",nestedSheetGUID,\"with index\",nestedSheetIndex,\"from line\",originLineGUID,\"with index\",refLineIndex,\"at column\",refLineColumn.name,\"with guid\",refLineColumn.guid)\n                    for (let index = 1; index <= event.detail.data.amount; index++) {\n                        var newLine = {};\n                        newLine[\"guid\"] = uuidv4();\n                        fullData.sheets[nestedSheetIndex].columns.forEach(column => {\n                            if(column.typeStr == \"multiple\")\n                            {\n                                newLine[column.name] = column.defaultValue.split(', ');\n                            }\n                            else\n                            {\n                                newLine[column.name] = column.defaultValue;\n                            }\n                        });\n                        if(!fullData.sheets[nestedSheetIndex].isProps) {\n                            newLine[\"id\"] = lineData[refLineIndex][refLineColumn.name].length + \"\";\n                            lineData[refLineIndex][refLineColumn.name].push(newLine);\n                        } else {\n                            lineData[refLineIndex][refLineColumn.name] = newLine;\n                        }\n                    }\n                    break;\n                case \"remove\":\n                    if(!fullData.sheets[nestedSheetIndex].isProps) {\n                        lineData[refLineIndex][refLineColumn.name].splice(event.detail.data.lineIndex,1);\n                    } else {\n                        //note this doesnt remove the props config, just this entry in this line\n                        lineData[refLineIndex][refLineColumn.name] = {};\n                    }\n                    //delete this from visibility\n                    //TODO: if the line has nested lists as well that are visbile, this needs to delete those lines as well from visbility\n                    //this doesn't happen right now so creates some garbage in listVisibility\n                    if(lineData[refLineIndex].guid in listVisibility)\n                    {\n                        delete listVisibility[refLineIndex];\n                    }\n                    //nested sheet lines cannot be referened so we can just delete this from the list\n                    break;\n                default:\n                    break;\n            }\n            //push updates\n            dispatch('message', {\n                \"type\" : \"update\",\n                \"data\" : {\n                    \"sheetGUID\" : nestedSheetGUID\n                }\n            });\n            break;\n        case \"hoverUpdate\":\n            let actionSheet = event.detail.data.sheetGUID;\n            switch (event.detail.data.action) {\n                case \"enter\":\n                    lastHovered = actionSheet;\n                    break;\n                case \"exit\":\n                    if(event.detail.data.parentGUID === sheetData.guid) {\n                        lastHovered = sheetData.guid;\n                    }\n                    break;\n            }\n            // dispatch('message', {\n            //     \"type\" : \"update\",\n            //     \"data\" : {\n            //         \"sheetGUID\" : nestedSheetGUID\n            //     }\n            // });\n            dispatch('message',event.detail);\n            break;\n        default:\n            //forward messages otherwise from nested table\n            dispatch('message',event.detail);\n            break;\n    }\n}\n\nlet totalColumns = 0;\n$: {\n    console.log(sheetData);\n    if(showLineGUIDs)\n    {\n        totalColumns = sheetData.columns.length + 3;\n    }\n    else\n    {\n        totalColumns = sheetData.columns.length + 2; \n    }\n} \n\n\nfunction setListVisible(line,column,visible) {\n    if(visible) {\n        listVisibility[line.guid] = column;\n    }\n    else {\n        delete listVisibility[line.guid];\n    }\n    //https://svelte.dev/tutorial/updating-arrays-and-objects\n    listVisibility = listVisibility;\n}\n\nfunction validateID(event,line) {\n    switch (event.detail.type) {\n        case \"validate\":\n            lineData.forEach(ld => {\n                if(line.guid !== ld.guid && line.id === ld.id)\n                {\n                   let index = lineData.findIndex(l => l.guid === line.guid);\n                   lineData[index].id = \"DUPLICATE(\"+line.id+\")\";\n                }\n            });\n            dispatch('message', {\n                \"type\" : \"update\",\n                \"data\" : {\n                    \"sheetGUID\" : sheetData.guid\n                }\n            });\n            break;\n        default:\n            //forward messages otherwise from nested table\n            dispatch('message',event.detail);\n            break;\n    }\n}\n\n</script>\n    <table on:mouseenter={enterSheet} on:mouseleave={leaveSheet}>\n    <!-- This checks if this is a nested sheet, in which case we want to have the UI visible -->\n    {#if sheetData.hidden}\n        {#if lastHovered == sheetData.guid && allowSchemaEditing}\n        <tr>\n            <td colspan=\"{totalColumns}\">\n                {#each Object.keys(defaults) as columnType}\n                    {#if columnType !== \"sheet\"}\n                    <button class=\"buttonIcon padded\" title=\"Create new {columnType} column\" on:click={() => createColumn(columnType)}>\n                        <img src={iconPaths[defaults[columnType].iconName].path} alt=\"Create new {columnType} column\">\n                    </button>\n                    {/if}\n                {/each}\n            </td>\n        </tr>\n        {/if}\n        {#if showNestedNames || showNestedPaths}\n        <tr>\n            <td colspan=\"{totalColumns}\">\n                {#if showNestedNames}<b>{sheetData.name}</b>{/if} {#if showNestedPaths} @ {baseDataPath}{/if}\n            </td>\n        </tr>\n        {/if}\n    {/if}\n    <tr>\n        <th>    </th>\n        {#if showLineGUIDs}\n        <th>GUID</th>\n        {/if}\n        {#if !sheetData.isProps}\n        <th>ID</th>\n        {/if}\n        {#each sheetData.columns as column}\n            <th title=\"{column.description}\">{#if allowSchemaEditing}<a href={\"#\"} on:click={()=> editColumn(column.name)}>{column.name}</a>{:else}{column.name}{/if}</th>\n        {/each}\n    </tr>\n    {#each lineData as line, i}\n    <!-- this prevents us from preemptively drawing empty an empty props entry -->\n    {#if Object.keys(line).length !== 0}\n        <tr>\n            <td style=\"width:17px\">\n                {#if allowAddRemoveItems}\n                    <button class=\"buttonIcon\" title=\"Remove Line\" on:click={() => removeLine(i,line,originLineGUID)}>\n                        <img style=\"max-width:17px\" src={iconPaths[\"removeLine\"].path} alt=\"Remove Line\">\n                    </button>\n                {/if}\n            </td>\n            {#if showLineGUIDs}\n            <td>{line.guid}</td>\n            {/if}\n            {#if !sheetData.isProps}\n            <td><TextField sheetGUID={sheetData.guid} bind:data={line[\"id\"]} on:message={(event) => validateID(event,line)}/></td>\n            {/if}\n            {#each sheetData.columns as column, c}\n                <td title=\"{column.description}\">\n                <div>\n                <!-- message from field updates bubble to Depot.svelte -->\n                {#if column.typeStr === \"text\"}\n                <TextField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message/>\n                {:else if column.typeStr === \"longtext\"}\n                <LongTextField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message/>\n                {:else if column.typeStr === \"image\"}\n                <ImageField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message fileKey={{\"line\":line,\"lineIndex\":i,\"column\":column,\"columnIndex\":c}}/>\n                {:else if column.typeStr === \"file\"}\n                <FileField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message fileKey={{\"line\":line,\"lineIndex\":i,\"column\":column,\"columnIndex\":c}}/>\n                {:else if column.typeStr === \"bool\"}\n                <BooleanField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message/>\n                {:else if column.typeStr === \"enum\"}\n                <EnumField sheetGUID={sheetData.guid} bind:data={line[column.name]} options={sheetData.columns.find(x => x.name === column.name).options.split(', ')} on:message/>\n                {:else if column.typeStr === \"sheetReference\"}\n                <EnumField sheetGUID={sheetData.guid} bind:data={line[column.name]} options={depotInfo.sheetsFiltered.guids} aliases={depotInfo.sheetsFiltered.names} on:message/>\n                {:else if column.typeStr === \"lineReference\"}\n                    {#if column.sheet !== \"\"}\n                    <EnumField sheetGUID={sheetData.guid} bind:data={line[column.name]} \n                                options={depotInfo.lines[column.sheet].guids} \n                                aliases={depotInfo.lines[column.sheet].names} on:message/>\n                    {:else}\n                    <EnumField sheetGUID={sheetData.guid} bind:data={line[column.name]} \n                                options={[]} \n                                aliases={[]} on:message/>\n                    {/if}\n                    {#if line[column.name] !== \"\" && !depotInfo.lines[column.sheet].guids.includes(line[column.name])}\n                        <div title=\"Selected value with GUID {line[column.name]} not in selected sheet. Select proper sheet in column settings\">ERROR</div>\n                    {/if}\n                {:else if column.typeStr === \"multiple\"}\n                <MultipleField sheetGUID={sheetData.guid} bind:data={line[column.name]} options={sheetData.columns.find(x => x.name === column.name).options.split(', ')} displayType={\"displayType\" in column ? column.displayType : \"vertical\"} on:message/>\n                {:else if column.typeStr === \"int\" || column.typeStr === \"float\"}\n                <NumberField sheetGUID={sheetData.guid} bind:data={line[column.name]} on:message/>\n                {:else if column.typeStr === \"list\" || column.typeStr === \"props\" || column.typeStr === \"grid\"}\n                    {#if line.guid in listVisibility && listVisibility[line.guid].guid === column.guid}\n                        <button class=\"buttonIcon\" on:click={()=>setListVisible(line,column,false)}>\n                            <img src={iconPaths[\"showList\"].path} alt=\"Hide {column.typeStr}\">\n                        </button>\n                        ...\n                    {:else}\n                        <button class=\"buttonIcon\" on:click={()=>setListVisible(line,column,true)}>\n                            <img src={iconPaths[\"hideList\"].path} alt=\"Show {column.typeStr}\">\n                        </button>\n                        {#if previewDisclosedFields}\n                        {#if column.typeStr === \"list\"}\n                            <!-- Preview list contents  -->\n                            {#if line[column.name].length > 0 && line[column.name].length <= 5}\n                                {column.name} ({line[column.name].length}) : {line[column.name].map(l => l.id)}\n                            {:else if line[column.name].length > 5}\n                                {column.name} ({line[column.name].length}) : {line[column.name].map(l => l.id).slice(0, 4)}...\n                            {/if}\n                        {:else if column.typeStr === \"props\"}\n                            <!-- Preview props contents  -->\n                            {#each Object.keys(line[column.name]) as k, index}\n                                {#if k !== \"guid\" && index < 5}\n                                    {k} : {line[column.name][k]},\n                                {/if}\n                            {/each}\n                            ...\n                        {:else if column.typeStr === \"grid\"}\n                            <!-- Preview grid contents  -->\n                            {#if line[column.name].length > 0 && line[column.name].length <= 5}\n                                {line[column.name]}\n                            {:else if line[column.name].length > 5}\n                                {line[column.name].slice(0, 4)}...\n                            {/if}\n                        {/if}\n                        {/if}\n                    {/if}\n                {/if}\n                </div>\n                </td>\n            {/each}\n        </tr>\n        <!-- if line has a hidden sheet currently set to visible -->\n        <!-- listVisibility is guid, column  -->\n        {#if line.guid in listVisibility}\n        <!-- maybe pull this out of the tr and just use a div? -->\n            <tr>\n            {#if listVisibility[line.guid].typeStr === \"list\" || listVisibility[line.guid].typeStr === \"props\"}\n                <td></td>\n                <td colspan=\"{totalColumns -  1}\">\n                    <!--    lineData grabs itself from the values in the lineData in this sheet\n                            this is because lines store their nested values inside of themsevles instead of inside the sheet -->\n                    <svelte:self    debug={debug} \n                                    showLineGUIDs={showLineGUIDs} \n                                    showNestedNames={showNestedNames}\n                                    showNestedPaths={showNestedPaths}\n                                    allowSchemaEditing={allowSchemaEditing}\n                                    allowAddRemoveItems={allowAddRemoveItems}\n                                    originLineGUID={line.guid}\n                                    bind:fullData={fullData} \n                                    bind:sheetData={fullData.sheets[fullData.sheets.findIndex(sheet => sheet.guid === listVisibility[line.guid].sheet)]} \n                                    bind:inputLineData={lineData[lineData.findIndex(refLine => refLine.guid === line.guid)] \n                                                        [listVisibility[line.guid].name]} \n                                    depotInfo={depotInfo} \n                                    on:message={handleSubTableEvent}\n                                    bind:listVisibility={listVisibility}\n                                    bind:lastHovered={lastHovered}\n                                    parentGUID={sheetData.guid}\n                                    baseDataPath={baseDataPath + (sheetData.isProps ? \".\" : \"[\" + i + \"].\") + fullData.sheets[fullData.sheets.findIndex(sheet => sheet.guid === listVisibility[line.guid].sheet)].name}/>\n                                    <!-- baseDataPath={listVisibility[line.guid].typeStr === \"list\" ? baseDataPath + \"[\" + i + \"]\" : baseDataPath + \".\" + fullData.sheets[fullData.sheets.findIndex(sheet => sheet.guid === listVisibility[line.guid].sheet)].name }/> -->\n                </td>\n            {:else if listVisibility[line.guid].typeStr === \"grid\"}\n                <td></td>\n                <td colspan=\"{totalColumns -  1}\">\n                    <GridFieldTableEditor sheetGUID={sheetData.guid} \n                                          bind:data={line[listVisibility[line.guid].name]} \n                                          bind:columnData={listVisibility[line.guid]} \n                                          on:message/>\n                </td>\n            {/if}\n            </tr>\n        {/if}\n    {/if}\n    {/each}\n    {#if allowAddRemoveItems}\n        <!-- dont allow more than one line for a props sheet -->\n        {#if sheetData.isProps && Object.keys(inputLineData).length === 0}\n        <tr>\n            <td></td>\n            <td colspan=\"{totalColumns -  1}\">\n                <button class=\"buttonIcon addLine\" title=\"Add props\" on:click={() => addLines(1,originLineGUID)}>\n                    <img src={iconPaths[\"addPropsLine\"].path} alt=\"Add props\">\n                </button>\n            </td>\n        </tr>\n        {:else if !sheetData.isProps}\n        <tr>\n            <td></td>\n            <td colspan=\"{totalColumns -  1}\">\n                <button class=\"buttonIcon addLine\" title=\"Add one line\" on:click={() => addLines(1,originLineGUID)}>\n                    <img src={iconPaths[\"addOneLine\"].path} alt=\"Add one line\">\n                </button>\n                <button class=\"buttonIcon addLine\" title=\"Add five lines\" on:click={() => addLines(5,originLineGUID)}>\n                    <img src={iconPaths[\"addFiveLines\"].path} alt=\"Add five lines\">\n                </button>\n                <button class=\"buttonIcon addLine\" alt=\"Add ten lines\" on:click={() => addLines(10,originLineGUID)}>\n                    <img src={iconPaths[\"addTenLines\"].path} alt=\"Add ten lines\">\n                </button>\n            </td>\n        </tr>\n        {/if}\n    {/if}\n    </table>\n{#if debug}\n<p>Current Table Data:</p>\n<pre>{JSON.stringify({sheetData},null,2)}</pre>\n<p>----------------------------------------</p>\n{/if}\n\n<style>\n    .buttonIcon {\n        background-color: #3A3A3A;\n        border: none;\n        color: white;\n        display: inline-block;\n        cursor: pointer;\n    }\n    .buttonIcon:hover {\n        background-color: #2A2D2E;\n    }\n    .buttonIcon:focus {\n        outline: none;\n        box-shadow: none;\n    }\n    .buttonIcon:active:focus {\n        outline: none;\n        box-shadow: none;\n    }\n    .buttonIcon.padded {\n        margin: 5px 5px 5px 0px;\n        width: 45px;\n        height: 45px;\n    }\n    .buttonIcon.addLine {\n        margin: 5px 0px 5px 0px;\n        padding: 0px 0px 0px 0px;\n    }\n</style>",
    "<script>\n    import { getContext } from 'svelte';\n    import { createEventDispatcher } from 'svelte';\n    import tippy from 'sveltejs-tippy';\n\n    export let data;\n    export let sheetGUID;\n    export let fileKey;\n\n    $: props = {\n        content:\n        '<img src=\"'+data+'\">',\n        allowHTML: true,\n        placement: \"bottom\",\n        duration: [0, 0]\n    };\n\n    const nonce = getContext(\"nonce\");\n    const dispatch = createEventDispatcher();\n    function pickFile() {\n        dispatch('message', {\n            \"type\" : \"pickFile\",\n            \"fileKey\" : fileKey,\n            \"data\" : {\n                \"sheetGUID\" : sheetGUID\n            }\n        });\n    }\n    function clearFile() {\n        data = \"\";\n        dispatch('message', {\n            \"type\" : \"update\",\n            \"data\" : {\n                \"sheetGUID\" : sheetGUID\n            }\n        });\n    }\n\n    let hovering = false;\n\n</script>\n\n<style>\n    .row {\n        display: flex;\n        width: 75px;\n    }\n    .bCol {\n        display: flex;\n        flex-direction: column;\n        width: 25px;\n        height: 50px;\n        align-items: stretch\n    }\n</style>\n\n<div on:mouseover={()=>{hovering=true}} on:mouseleave={()=>{hovering=false}}>\n    <!-- <button>Test</button> -->\n    {#if data == \"\"}\n        <button on:click={pickFile}>Pick</button>\n    {:else}\n        <div class=\"row\">\n            <img style=\"width:50px;\" src={data} title={data} alt={data} use:tippy={props} on:click={pickFile}>\n            {#if hovering}\n                <div class=\"bCol\">\n                    <button style=\"height: 25px\" title=\"Clear image\" on:click={clearFile}>X</button>\n                    <button style=\"height: 25px\" title=\"Change image\" on:click={pickFile}>...</button>\n                </div>\n            {/if}\n        </div>\n{/if}\n</div>",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n\n    export let data;\n    export let sheetGUID;\n    export let min;\n    export let max;\n    const dispatch = createEventDispatcher();\n    function fieldUpdated() {\n        dispatch('message', {\n            \"type\" : \"update\",\n            \"data\" : {\n                \"sheetGUID\" : sheetGUID\n            }\n        });\n    }\n</script>\n<input type=number bind:value={data} min={min} max={max} on:input={fieldUpdated}>\n\n<style>\n    input {\n        padding: 5px 5px 5px 5px;\n        /* margin: 5px; */\n        box-sizing: border-box;\n        -webkit-box-sizing:border-box;\n        -moz-box-sizing: border-box;\n        border: 0px;\n        font-size: 13px;\n        border-width: 0px;\n        background-color: #3c3c3c;\n        color: #f0f0f0;\n        width: 100%;\n        height: 100%;\n        box-sizing: border-box;\n    }\n</style>",
    "<script>\n    import { createEventDispatcher } from 'svelte';\n\n    export let data;\n    export let sheetGUID;\n    const dispatch = createEventDispatcher();\n    function fieldUpdated() {\n        dispatch('message', {\n            \"type\" : \"update\",\n            \"data\" : {\n                \"sheetGUID\" : sheetGUID\n            }\n        });\n    }\n    function validateText() {\n        dispatch('message', {\n            \"type\" : \"validate\",\n            \"data\" : {\n                \"sheetGUID\" : sheetGUID\n            }\n        });\n    }\n</script>\n<input bind:value={data} on:blur={validateText} on:input={fieldUpdated}>\n\n<style>\n    input {\n        padding: 5px 5px 5px 5px;\n        /* margin: 5px; */\n        box-sizing: border-box;\n        -webkit-box-sizing:border-box;\n        -moz-box-sizing: border-box;\n        border: 0px;\n        font-size: 13px;\n        border-width: 0px;\n        background-color: #3c3c3c;\n        color: #f0f0f0;\n        width: 100%;\n        height: 100%;\n        box-sizing: border-box;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "AAqJC,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAI3B,CAAC,AAGO,KAAK,AAAE,CAAC,AAET,KAAK,CAAE,IAAI,CACX,UAAU,CAAE,IAAI,CAChB,eAAe,CAAE,QAAQ,AAC7B,CAAC,AACO,kBAAkB,AAAE,CAAC,AACzB,OAAO,GAAG,CAAC,KAAK,CAAC,OAAO,CACxB,OAAO,CAAE,GAAG,AAEhB,CAAC,AACO,cAAc,AAAE,CAAC,AACrB,SAAS,CAAE,IAAI,AACnB,CAAC,AACO,sBAAsB,AAAE,CAAC,AAE7B,OAAO,CAAE,GAAG,AAChB,CAAC,AACO,QAAQ,AAAE,CAAC,AACf,UAAU,CAAE,OAAO,CACnB,SAAS,CAAE,IAAI,CACf,WAAW,CAAE,IAAI,CACjB,UAAU,CAAE,IAAI,AACpB,CAAC;ACqmBD,WAAW,eAAC,CAAC,AACT,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,OAAO,AACnB,CAAC,AAED,0BAAW,MAAM,AAAC,CAAC,AACf,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AAED,0BAAW,MAAM,AAAC,CAAC,AACf,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC,AACD,0BAAW,OAAO,MAAM,AAAC,CAAC,AACtB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC,AACD,WAAW,OAAO,eAAC,CAAC,AAChB,MAAM,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAChB,CAAC,AAED,YAAY,eAAC,CAAC,AACV,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,OAAO,CACf,MAAM,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CACvB,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,AAC5B,CAAC,AACD,2BAAY,MAAM,AAAC,CAAC,AAChB,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AACD,YAAY,SAAS,eAAC,CAAC,AACnB,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AACD,2BAAY,MAAM,AAAC,CAAC,AAChB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC,AACD,2BAAY,OAAO,MAAM,AAAC,CAAC,AACvB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC;AClWD,WAAW,eAAC,CAAC,AACT,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,KAAK,CACZ,OAAO,CAAE,YAAY,CACrB,MAAM,CAAE,OAAO,AACnB,CAAC,AACD,0BAAW,MAAM,AAAC,CAAC,AACf,gBAAgB,CAAE,OAAO,AAC7B,CAAC,AACD,0BAAW,MAAM,AAAC,CAAC,AACf,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC,AACD,0BAAW,OAAO,MAAM,AAAC,CAAC,AACtB,OAAO,CAAE,IAAI,CACb,UAAU,CAAE,IAAI,AACpB,CAAC,AACD,WAAW,OAAO,eAAC,CAAC,AAChB,MAAM,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CACvB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,AAChB,CAAC,AACD,WAAW,QAAQ,eAAC,CAAC,AACjB,MAAM,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CACvB,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,AAC5B,CAAC;ACrdD,IAAI,cAAC,CAAC,AACF,OAAO,CAAE,IAAI,CACb,KAAK,CAAE,IAAI,AACf,CAAC,AACD,KAAK,cAAC,CAAC,AACH,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,CACtB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,OAAO;IACxB,CAAC;ACjCD,KAAK,eAAC,CAAC,AACH,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAExB,UAAU,CAAE,UAAU,CACtB,mBAAmB,UAAU,CAC7B,eAAe,CAAE,UAAU,CAC3B,MAAM,CAAE,GAAG,CACX,SAAS,CAAE,IAAI,CACf,YAAY,CAAE,GAAG,CACjB,gBAAgB,CAAE,OAAO,CACzB,KAAK,CAAE,OAAO,CACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,UAAU,AAC1B,CAAC;ACRD,KAAK,eAAC,CAAC,AACH,OAAO,CAAE,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAExB,UAAU,CAAE,UAAU,CACtB,mBAAmB,UAAU,CAC7B,eAAe,CAAE,UAAU,CAC3B,MAAM,CAAE,GAAG,CACX,SAAS,CAAE,IAAI,CACf,YAAY,CAAE,GAAG,CACjB,gBAAgB,CAAE,OAAO,CACzB,KAAK,CAAE,OAAO,CACd,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,UAAU,AAC1B,CAAC"
}